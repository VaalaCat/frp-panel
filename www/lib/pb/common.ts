// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "common.proto" (package "common", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message common.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: common.RespCode code = 1;
     */
    code: RespCode;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * @generated from protobuf message common.CommonRequest
 */
export interface CommonRequest {
    /**
     * @generated from protobuf field: optional string data = 1;
     */
    data?: string;
}
/**
 * @generated from protobuf message common.CommonResponse
 */
export interface CommonResponse {
    /**
     * @generated from protobuf field: optional common.Status status = 1;
     */
    status?: Status;
    /**
     * @generated from protobuf field: optional string data = 2;
     */
    data?: string;
}
/**
 * @generated from protobuf message common.Client
 */
export interface Client {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * @generated from protobuf field: optional string secret = 2;
     */
    secret?: string;
    /**
     * @generated from protobuf field: optional string config = 3;
     */
    config?: string;
    /**
     * @generated from protobuf field: optional string comment = 5;
     */
    comment?: string; // 用户自定义的备注
    /**
     * @generated from protobuf field: optional string server_id = 6;
     */
    serverId?: string;
    /**
     * @generated from protobuf field: optional bool stopped = 7;
     */
    stopped?: boolean;
    /**
     * @generated from protobuf field: repeated string client_ids = 8;
     */
    clientIds: string[]; // some client can connected to more than one server, make a shadow client to handle this
    /**
     * @generated from protobuf field: optional string origin_client_id = 9;
     */
    originClientId?: string;
    /**
     * @generated from protobuf field: optional string frps_url = 10;
     */
    frpsUrl?: string; // 客户端用于连接frps的url，解决 frp 在 CDN 后的问题，格式类似 [tcp/ws/wss/quic/kcp]://example.com:7000
    /**
     * @generated from protobuf field: optional bool ephemeral = 11;
     */
    ephemeral?: boolean; // 是否临时节点
    /**
     * @generated from protobuf field: optional int64 last_seen_at = 12;
     */
    lastSeenAt?: bigint; // 最后一次心跳时间戳
}
/**
 * @generated from protobuf message common.Server
 */
export interface Server {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * @generated from protobuf field: optional string secret = 2;
     */
    secret?: string;
    /**
     * @generated from protobuf field: optional string ip = 3;
     */
    ip?: string;
    /**
     * @generated from protobuf field: optional string config = 4;
     */
    config?: string; // 在定义上，ip和port只是为了方便使用
    /**
     * @generated from protobuf field: optional string comment = 5;
     */
    comment?: string; // 用户自定义的备注
    /**
     * @generated from protobuf field: repeated string frps_urls = 6;
     */
    frpsUrls: string[]; // 客户端用于连接frps的url，解决 frp 在 CDN 后的问题，格式类似 [tcp/ws/wss/quic/kcp]://example.com:7000，可以有多个
}
/**
 * @generated from protobuf message common.User
 */
export interface User {
    /**
     * @generated from protobuf field: optional int64 UserID = 1 [json_name = "UserID"];
     */
    userID?: bigint;
    /**
     * @generated from protobuf field: optional int64 TenantID = 2 [json_name = "TenantID"];
     */
    tenantID?: bigint;
    /**
     * @generated from protobuf field: optional string UserName = 3 [json_name = "UserName"];
     */
    userName?: string;
    /**
     * @generated from protobuf field: optional string Email = 4 [json_name = "Email"];
     */
    email?: string;
    /**
     * @generated from protobuf field: optional string Status = 5 [json_name = "Status"];
     */
    status?: string;
    /**
     * @generated from protobuf field: optional string Role = 6 [json_name = "Role"];
     */
    role?: string;
    /**
     * @generated from protobuf field: optional string Token = 7 [json_name = "Token"];
     */
    token?: string;
    /**
     * @generated from protobuf field: optional string RawPassword = 8 [json_name = "RawPassword"];
     */
    rawPassword?: string;
}
/**
 * @generated from protobuf message common.ProxyInfo
 */
export interface ProxyInfo {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string type = 2;
     */
    type?: string;
    /**
     * @generated from protobuf field: optional string client_id = 3;
     */
    clientId?: string;
    /**
     * @generated from protobuf field: optional string server_id = 4;
     */
    serverId?: string;
    /**
     * @generated from protobuf field: optional int64 today_traffic_in = 5;
     */
    todayTrafficIn?: bigint;
    /**
     * @generated from protobuf field: optional int64 today_traffic_out = 6;
     */
    todayTrafficOut?: bigint;
    /**
     * @generated from protobuf field: optional int64 history_traffic_in = 7;
     */
    historyTrafficIn?: bigint;
    /**
     * @generated from protobuf field: optional int64 history_traffic_out = 8;
     */
    historyTrafficOut?: bigint;
    /**
     * @generated from protobuf field: optional bool first_sync = 9;
     */
    firstSync?: boolean;
}
/**
 * @generated from protobuf message common.ProxyConfig
 */
export interface ProxyConfig {
    /**
     * @generated from protobuf field: optional uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string type = 3;
     */
    type?: string;
    /**
     * @generated from protobuf field: optional string client_id = 4;
     */
    clientId?: string;
    /**
     * @generated from protobuf field: optional string server_id = 5;
     */
    serverId?: string;
    /**
     * @generated from protobuf field: optional string config = 6;
     */
    config?: string;
    /**
     * @generated from protobuf field: optional string origin_client_id = 7;
     */
    originClientId?: string;
    /**
     * @generated from protobuf field: optional bool stopped = 8;
     */
    stopped?: boolean;
}
/**
 * @generated from protobuf message common.ProxyWorkingStatus
 */
export interface ProxyWorkingStatus {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string type = 2;
     */
    type?: string;
    /**
     * @generated from protobuf field: optional string status = 3;
     */
    status?: string;
    /**
     * @generated from protobuf field: optional string err = 4;
     */
    err?: string;
    /**
     * @generated from protobuf field: optional string remote_addr = 5;
     */
    remoteAddr?: string;
}
/**
 * @generated from protobuf message common.Worker
 */
export interface Worker {
    /**
     * @generated from protobuf field: optional string worker_id = 1;
     */
    workerId?: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string; // worker's name, also use at worker routing, must be unique, default is UID
    /**
     * @generated from protobuf field: optional uint32 user_id = 3;
     */
    userId?: number; // worker's user id
    /**
     * @generated from protobuf field: optional uint32 tenant_id = 4;
     */
    tenantId?: number;
    /**
     * @generated from protobuf field: optional common.Socket socket = 5;
     */
    socket?: Socket; // worker's socket, platfrom will obtain free port while init worker
    /**
     * @generated from protobuf field: optional string code_entry = 6;
     */
    codeEntry?: string; // worker's entry file, default is 'entry.js'
    /**
     * @generated from protobuf field: optional string code = 7;
     */
    code?: string; // worker's code
    /**
     * @generated from protobuf field: optional string config_template = 8;
     */
    configTemplate?: string; // worker's capnp file template
}
/**
 * one WorkerList for one workerd instance
 *
 * @generated from protobuf message common.WorkerList
 */
export interface WorkerList {
    /**
     * @generated from protobuf field: repeated common.Worker workers = 1;
     */
    workers: Worker[];
    /**
     * @generated from protobuf field: optional string nodename = 2;
     */
    nodename?: string; // workerd runner host name, for HA
}
/**
 * @generated from protobuf message common.Socket
 */
export interface Socket {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string address = 2;
     */
    address?: string;
}
/**
 * @generated from protobuf enum common.RespCode
 */
export enum RespCode {
    /**
     * @generated from protobuf enum value: RESP_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: RESP_CODE_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: RESP_CODE_NOT_FOUND = 2;
     */
    NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: RESP_CODE_ALREADY_EXISTS = 3;
     */
    ALREADY_EXISTS = 3,
    /**
     * @generated from protobuf enum value: RESP_CODE_INVALID = 4;
     */
    INVALID = 4,
    /**
     * @generated from protobuf enum value: RESP_CODE_FINISH = 5;
     */
    FINISH = 5,
    /**
     * @generated from protobuf enum value: RESP_CODE_UNAUTHORIZED = 6;
     */
    UNAUTHORIZED = 6
}
/**
 * @generated from protobuf enum common.ClientType
 */
export enum ClientType {
    /**
     * @generated from protobuf enum value: CLIENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CLIENT_TYPE_FRPC = 1;
     */
    FRPC = 1,
    /**
     * @generated from protobuf enum value: CLIENT_TYPE_FRPS = 2;
     */
    FRPS = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("common.Status", [
            { no: 1, name: "code", kind: "enum", T: () => ["common.RespCode", RespCode, "RESP_CODE_"] },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.RespCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.RespCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonRequest$Type extends MessageType<CommonRequest> {
    constructor() {
        super("common.CommonRequest", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommonRequest>): CommonRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CommonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonRequest): CommonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.CommonRequest
 */
export const CommonRequest = new CommonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonResponse$Type extends MessageType<CommonResponse> {
    constructor() {
        super("common.CommonResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommonResponse>): CommonResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CommonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonResponse): CommonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional common.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* optional string data */ 2:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional common.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.CommonResponse
 */
export const CommonResponse = new CommonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client$Type extends MessageType<Client> {
    constructor() {
        super("common.Client", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "secret", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "config", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "comment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "server_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "stopped", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "client_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "origin_client_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "frps_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "ephemeral", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "last_seen_at", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Client>): Client {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientIds = [];
        if (value !== undefined)
            reflectionMergePartial<Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client): Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string secret */ 2:
                    message.secret = reader.string();
                    break;
                case /* optional string config */ 3:
                    message.config = reader.string();
                    break;
                case /* optional string comment */ 5:
                    message.comment = reader.string();
                    break;
                case /* optional string server_id */ 6:
                    message.serverId = reader.string();
                    break;
                case /* optional bool stopped */ 7:
                    message.stopped = reader.bool();
                    break;
                case /* repeated string client_ids */ 8:
                    message.clientIds.push(reader.string());
                    break;
                case /* optional string origin_client_id */ 9:
                    message.originClientId = reader.string();
                    break;
                case /* optional string frps_url */ 10:
                    message.frpsUrl = reader.string();
                    break;
                case /* optional bool ephemeral */ 11:
                    message.ephemeral = reader.bool();
                    break;
                case /* optional int64 last_seen_at */ 12:
                    message.lastSeenAt = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string secret = 2; */
        if (message.secret !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.secret);
        /* optional string config = 3; */
        if (message.config !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.config);
        /* optional string comment = 5; */
        if (message.comment !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.comment);
        /* optional string server_id = 6; */
        if (message.serverId !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.serverId);
        /* optional bool stopped = 7; */
        if (message.stopped !== undefined)
            writer.tag(7, WireType.Varint).bool(message.stopped);
        /* repeated string client_ids = 8; */
        for (let i = 0; i < message.clientIds.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.clientIds[i]);
        /* optional string origin_client_id = 9; */
        if (message.originClientId !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.originClientId);
        /* optional string frps_url = 10; */
        if (message.frpsUrl !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.frpsUrl);
        /* optional bool ephemeral = 11; */
        if (message.ephemeral !== undefined)
            writer.tag(11, WireType.Varint).bool(message.ephemeral);
        /* optional int64 last_seen_at = 12; */
        if (message.lastSeenAt !== undefined)
            writer.tag(12, WireType.Varint).int64(message.lastSeenAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.Client
 */
export const Client = new Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server$Type extends MessageType<Server> {
    constructor() {
        super("common.Server", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "secret", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "config", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "comment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "frps_urls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Server>): Server {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frpsUrls = [];
        if (value !== undefined)
            reflectionMergePartial<Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server): Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string secret */ 2:
                    message.secret = reader.string();
                    break;
                case /* optional string ip */ 3:
                    message.ip = reader.string();
                    break;
                case /* optional string config */ 4:
                    message.config = reader.string();
                    break;
                case /* optional string comment */ 5:
                    message.comment = reader.string();
                    break;
                case /* repeated string frps_urls */ 6:
                    message.frpsUrls.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string secret = 2; */
        if (message.secret !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.secret);
        /* optional string ip = 3; */
        if (message.ip !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.ip);
        /* optional string config = 4; */
        if (message.config !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.config);
        /* optional string comment = 5; */
        if (message.comment !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.comment);
        /* repeated string frps_urls = 6; */
        for (let i = 0; i < message.frpsUrls.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.frpsUrls[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.Server
 */
export const Server = new Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("common.User", [
            { no: 1, name: "UserID", kind: "scalar", jsonName: "UserID", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "TenantID", kind: "scalar", jsonName: "TenantID", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "UserName", kind: "scalar", jsonName: "UserName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "Email", kind: "scalar", jsonName: "Email", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "Status", kind: "scalar", jsonName: "Status", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "Role", kind: "scalar", jsonName: "Role", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "Token", kind: "scalar", jsonName: "Token", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "RawPassword", kind: "scalar", jsonName: "RawPassword", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 UserID = 1 [json_name = "UserID"];*/ 1:
                    message.userID = reader.int64().toBigInt();
                    break;
                case /* optional int64 TenantID = 2 [json_name = "TenantID"];*/ 2:
                    message.tenantID = reader.int64().toBigInt();
                    break;
                case /* optional string UserName = 3 [json_name = "UserName"];*/ 3:
                    message.userName = reader.string();
                    break;
                case /* optional string Email = 4 [json_name = "Email"];*/ 4:
                    message.email = reader.string();
                    break;
                case /* optional string Status = 5 [json_name = "Status"];*/ 5:
                    message.status = reader.string();
                    break;
                case /* optional string Role = 6 [json_name = "Role"];*/ 6:
                    message.role = reader.string();
                    break;
                case /* optional string Token = 7 [json_name = "Token"];*/ 7:
                    message.token = reader.string();
                    break;
                case /* optional string RawPassword = 8 [json_name = "RawPassword"];*/ 8:
                    message.rawPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 UserID = 1 [json_name = "UserID"]; */
        if (message.userID !== undefined)
            writer.tag(1, WireType.Varint).int64(message.userID);
        /* optional int64 TenantID = 2 [json_name = "TenantID"]; */
        if (message.tenantID !== undefined)
            writer.tag(2, WireType.Varint).int64(message.tenantID);
        /* optional string UserName = 3 [json_name = "UserName"]; */
        if (message.userName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.userName);
        /* optional string Email = 4 [json_name = "Email"]; */
        if (message.email !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* optional string Status = 5 [json_name = "Status"]; */
        if (message.status !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* optional string Role = 6 [json_name = "Role"]; */
        if (message.role !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.role);
        /* optional string Token = 7 [json_name = "Token"]; */
        if (message.token !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.token);
        /* optional string RawPassword = 8 [json_name = "RawPassword"]; */
        if (message.rawPassword !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.rawPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProxyInfo$Type extends MessageType<ProxyInfo> {
    constructor() {
        super("common.ProxyInfo", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "server_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "today_traffic_in", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "today_traffic_out", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "history_traffic_in", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "history_traffic_out", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "first_sync", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ProxyInfo>): ProxyInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProxyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProxyInfo): ProxyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string type */ 2:
                    message.type = reader.string();
                    break;
                case /* optional string client_id */ 3:
                    message.clientId = reader.string();
                    break;
                case /* optional string server_id */ 4:
                    message.serverId = reader.string();
                    break;
                case /* optional int64 today_traffic_in */ 5:
                    message.todayTrafficIn = reader.int64().toBigInt();
                    break;
                case /* optional int64 today_traffic_out */ 6:
                    message.todayTrafficOut = reader.int64().toBigInt();
                    break;
                case /* optional int64 history_traffic_in */ 7:
                    message.historyTrafficIn = reader.int64().toBigInt();
                    break;
                case /* optional int64 history_traffic_out */ 8:
                    message.historyTrafficOut = reader.int64().toBigInt();
                    break;
                case /* optional bool first_sync */ 9:
                    message.firstSync = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProxyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* optional string client_id = 3; */
        if (message.clientId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.clientId);
        /* optional string server_id = 4; */
        if (message.serverId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.serverId);
        /* optional int64 today_traffic_in = 5; */
        if (message.todayTrafficIn !== undefined)
            writer.tag(5, WireType.Varint).int64(message.todayTrafficIn);
        /* optional int64 today_traffic_out = 6; */
        if (message.todayTrafficOut !== undefined)
            writer.tag(6, WireType.Varint).int64(message.todayTrafficOut);
        /* optional int64 history_traffic_in = 7; */
        if (message.historyTrafficIn !== undefined)
            writer.tag(7, WireType.Varint).int64(message.historyTrafficIn);
        /* optional int64 history_traffic_out = 8; */
        if (message.historyTrafficOut !== undefined)
            writer.tag(8, WireType.Varint).int64(message.historyTrafficOut);
        /* optional bool first_sync = 9; */
        if (message.firstSync !== undefined)
            writer.tag(9, WireType.Varint).bool(message.firstSync);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.ProxyInfo
 */
export const ProxyInfo = new ProxyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProxyConfig$Type extends MessageType<ProxyConfig> {
    constructor() {
        super("common.ProxyConfig", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "client_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "server_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "config", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "origin_client_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "stopped", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ProxyConfig>): ProxyConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProxyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProxyConfig): ProxyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string type */ 3:
                    message.type = reader.string();
                    break;
                case /* optional string client_id */ 4:
                    message.clientId = reader.string();
                    break;
                case /* optional string server_id */ 5:
                    message.serverId = reader.string();
                    break;
                case /* optional string config */ 6:
                    message.config = reader.string();
                    break;
                case /* optional string origin_client_id */ 7:
                    message.originClientId = reader.string();
                    break;
                case /* optional bool stopped */ 8:
                    message.stopped = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProxyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string type = 3; */
        if (message.type !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* optional string client_id = 4; */
        if (message.clientId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.clientId);
        /* optional string server_id = 5; */
        if (message.serverId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.serverId);
        /* optional string config = 6; */
        if (message.config !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.config);
        /* optional string origin_client_id = 7; */
        if (message.originClientId !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.originClientId);
        /* optional bool stopped = 8; */
        if (message.stopped !== undefined)
            writer.tag(8, WireType.Varint).bool(message.stopped);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.ProxyConfig
 */
export const ProxyConfig = new ProxyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProxyWorkingStatus$Type extends MessageType<ProxyWorkingStatus> {
    constructor() {
        super("common.ProxyWorkingStatus", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "err", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "remote_addr", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProxyWorkingStatus>): ProxyWorkingStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProxyWorkingStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProxyWorkingStatus): ProxyWorkingStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string type */ 2:
                    message.type = reader.string();
                    break;
                case /* optional string status */ 3:
                    message.status = reader.string();
                    break;
                case /* optional string err */ 4:
                    message.err = reader.string();
                    break;
                case /* optional string remote_addr */ 5:
                    message.remoteAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProxyWorkingStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* optional string status = 3; */
        if (message.status !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* optional string err = 4; */
        if (message.err !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.err);
        /* optional string remote_addr = 5; */
        if (message.remoteAddr !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.remoteAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.ProxyWorkingStatus
 */
export const ProxyWorkingStatus = new ProxyWorkingStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Worker$Type extends MessageType<Worker> {
    constructor() {
        super("common.Worker", [
            { no: 1, name: "worker_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tenant_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "socket", kind: "message", T: () => Socket },
            { no: 6, name: "code_entry", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "config_template", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Worker>): Worker {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Worker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Worker): Worker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string worker_id */ 1:
                    message.workerId = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint32 user_id */ 3:
                    message.userId = reader.uint32();
                    break;
                case /* optional uint32 tenant_id */ 4:
                    message.tenantId = reader.uint32();
                    break;
                case /* optional common.Socket socket */ 5:
                    message.socket = Socket.internalBinaryRead(reader, reader.uint32(), options, message.socket);
                    break;
                case /* optional string code_entry */ 6:
                    message.codeEntry = reader.string();
                    break;
                case /* optional string code */ 7:
                    message.code = reader.string();
                    break;
                case /* optional string config_template */ 8:
                    message.configTemplate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Worker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string worker_id = 1; */
        if (message.workerId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.workerId);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional uint32 user_id = 3; */
        if (message.userId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.userId);
        /* optional uint32 tenant_id = 4; */
        if (message.tenantId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.tenantId);
        /* optional common.Socket socket = 5; */
        if (message.socket)
            Socket.internalBinaryWrite(message.socket, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string code_entry = 6; */
        if (message.codeEntry !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.codeEntry);
        /* optional string code = 7; */
        if (message.code !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.code);
        /* optional string config_template = 8; */
        if (message.configTemplate !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.configTemplate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.Worker
 */
export const Worker = new Worker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerList$Type extends MessageType<WorkerList> {
    constructor() {
        super("common.WorkerList", [
            { no: 1, name: "workers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Worker },
            { no: 2, name: "nodename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerList>): WorkerList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workers = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerList): WorkerList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated common.Worker workers */ 1:
                    message.workers.push(Worker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string nodename */ 2:
                    message.nodename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated common.Worker workers = 1; */
        for (let i = 0; i < message.workers.length; i++)
            Worker.internalBinaryWrite(message.workers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string nodename = 2; */
        if (message.nodename !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.nodename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.WorkerList
 */
export const WorkerList = new WorkerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Socket$Type extends MessageType<Socket> {
    constructor() {
        super("common.Socket", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Socket>): Socket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Socket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Socket): Socket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string address */ 2:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Socket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string address = 2; */
        if (message.address !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message common.Socket
 */
export const Socket = new Socket$Type();
