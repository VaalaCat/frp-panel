// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "types_wg.proto" (package "wireguard", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * WireGuardPeerConfig wg peer 的配置
 *
 * @generated from protobuf message wireguard.WireGuardPeerConfig
 */
export interface WireGuardPeerConfig {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * @generated from protobuf field: uint32 user_id = 3;
     */
    userId: number;
    /**
     * @generated from protobuf field: uint32 tenant_id = 4;
     */
    tenantId: number;
    /**
     * @generated from protobuf field: string public_key = 5;
     */
    publicKey: string; // Peer 的 wg 公钥
    /**
     * @generated from protobuf field: string preshared_key = 6;
     */
    presharedKey: string; // (可选) Peer 的 WireGuard 预共享密钥
    /**
     * @generated from protobuf field: repeated string allowed_ips = 7;
     */
    allowedIps: string[]; // 通过此 Peer 路由的 IP 地址/子网
    /**
     * @generated from protobuf field: wireguard.Endpoint endpoint = 8;
     */
    endpoint?: Endpoint; // (可选) Peer 的公网端点 "host:port"
    /**
     * @generated from protobuf field: uint32 persistent_keepalive = 9;
     */
    persistentKeepalive: number; // 可选
    /**
     * @generated from protobuf field: repeated string tags = 10;
     */
    tags: string[]; // 标签
    /**
     * @generated from protobuf field: string virtual_ip = 11;
     */
    virtualIp: string; // 节点虚拟 IP
}
/**
 * WireGuardConfig wg 配置
 *
 * @generated from protobuf message wireguard.WireGuardConfig
 */
export interface WireGuardConfig {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * @generated from protobuf field: uint32 user_id = 3;
     */
    userId: number;
    /**
     * @generated from protobuf field: uint32 tenant_id = 4;
     */
    tenantId: number;
    /**
     * @generated from protobuf field: string interface_name = 5;
     */
    interfaceName: string; // WireGuard 网络接口的名称
    /**
     * @generated from protobuf field: string private_key = 6;
     */
    privateKey: string; // 接口的私钥
    /**
     * @generated from protobuf field: string local_address = 7;
     */
    localAddress: string; // 虚拟接口的 CIDR
    /**
     * @generated from protobuf field: uint32 listen_port = 8;
     */
    listenPort: number; // (可选) WireGuard 监听端口，如果没有配置，则使用默认端口
    /**
     * @generated from protobuf field: uint32 interface_mtu = 9;
     */
    interfaceMtu: number; // 可选
    /**
     * @generated from protobuf field: repeated wireguard.WireGuardPeerConfig peers = 10;
     */
    peers: WireGuardPeerConfig[]; // Peer 列表
    /**
     * @generated from protobuf field: repeated wireguard.Endpoint advertised_endpoints = 11;
     */
    advertisedEndpoints: Endpoint[]; // (可选) 外部可连接的地址
    /**
     * @generated from protobuf field: repeated string dns_servers = 12;
     */
    dnsServers: string[]; // (可选) DNS 服务器列表
    /**
     * @generated from protobuf field: uint32 network_id = 13;
     */
    networkId: number; // 归属的网络 ID
    /**
     * @generated from protobuf field: repeated string tags = 14;
     */
    tags: string[]; // 标签
    /**
     * @generated from protobuf field: uint32 ws_listen_port = 15;
     */
    wsListenPort: number; // (可选) WebSocket 监听端口，如果没有配置，则使用默认端口
    /**
     * @generated from protobuf field: bool use_gvisor_net = 16;
     */
    useGvisorNet: boolean; // (可选) 是否使用 gvisor netstack，环境变量中的ture可以覆盖该配置
}
/**
 * @generated from protobuf message wireguard.Endpoint
 */
export interface Endpoint {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string host = 2;
     */
    host: string;
    /**
     * @generated from protobuf field: uint32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: string client_id = 4;
     */
    clientId: string;
    /**
     * @generated from protobuf field: uint32 wireguard_id = 5;
     */
    wireguardId: number; // 分配的 WireGuard ID
    /**
     * @generated from protobuf field: string uri = 6;
     */
    uri: string; // Endpoint支持多种类型，当类型为非UDP时，需要用到这个字段
    /**
     * @generated from protobuf field: string type = 7;
     */
    type: string; // Endpoint类型, 支持ws/udp
}
/**
 * @generated from protobuf message wireguard.WireGuardLink
 */
export interface WireGuardLink {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 from_wireguard_id = 2;
     */
    fromWireguardId: number;
    /**
     * @generated from protobuf field: uint32 to_wireguard_id = 3;
     */
    toWireguardId: number;
    /**
     * @generated from protobuf field: uint32 up_bandwidth_mbps = 4;
     */
    upBandwidthMbps: number;
    /**
     * @generated from protobuf field: uint32 down_bandwidth_mbps = 5;
     */
    downBandwidthMbps: number;
    /**
     * @generated from protobuf field: uint32 latency_ms = 6;
     */
    latencyMs: number;
    /**
     * @generated from protobuf field: bool active = 7;
     */
    active: boolean;
    /**
     * @generated from protobuf field: wireguard.Endpoint to_endpoint = 8;
     */
    toEndpoint?: Endpoint;
    /**
     * @generated from protobuf field: repeated string routes = 9;
     */
    routes: string[];
}
/**
 * @generated from protobuf message wireguard.WireGuardLinks
 */
export interface WireGuardLinks {
    /**
     * @generated from protobuf field: repeated wireguard.WireGuardLink links = 1;
     */
    links: WireGuardLink[];
}
/**
 * @generated from protobuf message wireguard.Network
 */
export interface Network {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 user_id = 2;
     */
    userId: number;
    /**
     * @generated from protobuf field: uint32 tenant_id = 3;
     */
    tenantId: number;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: string cidr = 5;
     */
    cidr: string;
    /**
     * @generated from protobuf field: wireguard.AclConfig acl = 6;
     */
    acl?: AclConfig;
}
/**
 * @generated from protobuf message wireguard.AclConfig
 */
export interface AclConfig {
    /**
     * @generated from protobuf field: repeated wireguard.AclRuleConfig acls = 1;
     */
    acls: AclRuleConfig[];
}
/**
 * @generated from protobuf message wireguard.AclRuleConfig
 */
export interface AclRuleConfig {
    /**
     * @generated from protobuf field: string action = 1;
     */
    action: string; // accept or deny
    /**
     * @generated from protobuf field: repeated string src = 2;
     */
    src: string[];
    /**
     * @generated from protobuf field: repeated string dst = 3;
     */
    dst: string[];
}
/**
 * @generated from protobuf message wireguard.WGPeerRuntimeInfo
 */
export interface WGPeerRuntimeInfo {
    /**
     * @generated from protobuf field: string public_key = 1;
     */
    publicKey: string;
    /**
     * @generated from protobuf field: string preshared_key = 2;
     */
    presharedKey: string;
    /**
     * @generated from protobuf field: repeated string allowed_ips = 3;
     */
    allowedIps: string[];
    /**
     * string endpoint_host = 4; // 不再使用
     * uint32 endpoint_port = 5; // 不再使用
     *
     * @generated from protobuf field: uint64 tx_bytes = 6;
     */
    txBytes: bigint;
    /**
     * @generated from protobuf field: uint64 rx_bytes = 7;
     */
    rxBytes: bigint;
    /**
     * @generated from protobuf field: uint32 persistent_keepalive_interval = 8;
     */
    persistentKeepaliveInterval: number;
    /**
     * @generated from protobuf field: uint64 last_handshake_time_nsec = 9;
     */
    lastHandshakeTimeNsec: bigint;
    /**
     * @generated from protobuf field: uint64 last_handshake_time_sec = 10;
     */
    lastHandshakeTimeSec: bigint;
    /**
     * @generated from protobuf field: string client_id = 11;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string endpoint = 12;
     */
    endpoint: string;
    /**
     * @generated from protobuf field: map<string, string> extra = 100;
     */
    extra: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message wireguard.WGDeviceRuntimeInfo
 */
export interface WGDeviceRuntimeInfo {
    /**
     * @generated from protobuf field: string private_key = 1;
     */
    privateKey: string;
    /**
     * @generated from protobuf field: uint32 listen_port = 2;
     */
    listenPort: number;
    /**
     * @generated from protobuf field: repeated wireguard.WGPeerRuntimeInfo peers = 3;
     */
    peers: WGPeerRuntimeInfo[];
    /**
     * @generated from protobuf field: uint32 protocol_version = 4;
     */
    protocolVersion: number;
    /**
     * @generated from protobuf field: int32 errno = 5;
     */
    errno: number;
    /**
     * @generated from protobuf field: string client_id = 6;
     */
    clientId: string;
    /**
     * @generated from protobuf field: map<uint32, uint32> ping_map = 7;
     */
    pingMap: {
        [key: number]: number;
    }; // to peer endpoint ping
    /**
     * @generated from protobuf field: string interface_name = 8;
     */
    interfaceName: string;
    /**
     * @generated from protobuf field: map<string, uint32> virt_addr_ping_map = 9;
     */
    virtAddrPingMap: {
        [key: string]: number;
    }; // to peer virtual address ping
    /**
     * @generated from protobuf field: map<string, uint32> peer_virt_addr_map = 10;
     */
    peerVirtAddrMap: {
        [key: string]: number;
    }; // to peer virtual address map
    /**
     * @generated from protobuf field: map<string, wireguard.WireGuardPeerConfig> peer_config_map = 11;
     */
    peerConfigMap: {
        [key: string]: WireGuardPeerConfig;
    }; // to peer config map
    /**
     * @generated from protobuf field: string virtual_ip = 12;
     */
    virtualIp: string; // 节点虚拟 IP
    /**
     * @generated from protobuf field: map<string, string> extra = 100;
     */
    extra: {
        [key: string]: string;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class WireGuardPeerConfig$Type extends MessageType<WireGuardPeerConfig> {
    constructor() {
        super("wireguard.WireGuardPeerConfig", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tenant_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "preshared_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "allowed_ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "endpoint", kind: "message", T: () => Endpoint },
            { no: 9, name: "persistent_keepalive", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "virtual_ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WireGuardPeerConfig>): WireGuardPeerConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.clientId = "";
        message.userId = 0;
        message.tenantId = 0;
        message.publicKey = "";
        message.presharedKey = "";
        message.allowedIps = [];
        message.persistentKeepalive = 0;
        message.tags = [];
        message.virtualIp = "";
        if (value !== undefined)
            reflectionMergePartial<WireGuardPeerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WireGuardPeerConfig): WireGuardPeerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* uint32 user_id */ 3:
                    message.userId = reader.uint32();
                    break;
                case /* uint32 tenant_id */ 4:
                    message.tenantId = reader.uint32();
                    break;
                case /* string public_key */ 5:
                    message.publicKey = reader.string();
                    break;
                case /* string preshared_key */ 6:
                    message.presharedKey = reader.string();
                    break;
                case /* repeated string allowed_ips */ 7:
                    message.allowedIps.push(reader.string());
                    break;
                case /* wireguard.Endpoint endpoint */ 8:
                    message.endpoint = Endpoint.internalBinaryRead(reader, reader.uint32(), options, message.endpoint);
                    break;
                case /* uint32 persistent_keepalive */ 9:
                    message.persistentKeepalive = reader.uint32();
                    break;
                case /* repeated string tags */ 10:
                    message.tags.push(reader.string());
                    break;
                case /* string virtual_ip */ 11:
                    message.virtualIp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WireGuardPeerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* uint32 user_id = 3; */
        if (message.userId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.userId);
        /* uint32 tenant_id = 4; */
        if (message.tenantId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.tenantId);
        /* string public_key = 5; */
        if (message.publicKey !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.publicKey);
        /* string preshared_key = 6; */
        if (message.presharedKey !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.presharedKey);
        /* repeated string allowed_ips = 7; */
        for (let i = 0; i < message.allowedIps.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.allowedIps[i]);
        /* wireguard.Endpoint endpoint = 8; */
        if (message.endpoint)
            Endpoint.internalBinaryWrite(message.endpoint, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 persistent_keepalive = 9; */
        if (message.persistentKeepalive !== 0)
            writer.tag(9, WireType.Varint).uint32(message.persistentKeepalive);
        /* repeated string tags = 10; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.tags[i]);
        /* string virtual_ip = 11; */
        if (message.virtualIp !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.virtualIp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WireGuardPeerConfig
 */
export const WireGuardPeerConfig = new WireGuardPeerConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WireGuardConfig$Type extends MessageType<WireGuardConfig> {
    constructor() {
        super("wireguard.WireGuardConfig", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tenant_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "interface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "private_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "local_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "listen_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "interface_mtu", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "peers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WireGuardPeerConfig },
            { no: 11, name: "advertised_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint },
            { no: 12, name: "dns_servers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "network_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "ws_listen_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "use_gvisor_net", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WireGuardConfig>): WireGuardConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.clientId = "";
        message.userId = 0;
        message.tenantId = 0;
        message.interfaceName = "";
        message.privateKey = "";
        message.localAddress = "";
        message.listenPort = 0;
        message.interfaceMtu = 0;
        message.peers = [];
        message.advertisedEndpoints = [];
        message.dnsServers = [];
        message.networkId = 0;
        message.tags = [];
        message.wsListenPort = 0;
        message.useGvisorNet = false;
        if (value !== undefined)
            reflectionMergePartial<WireGuardConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WireGuardConfig): WireGuardConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* uint32 user_id */ 3:
                    message.userId = reader.uint32();
                    break;
                case /* uint32 tenant_id */ 4:
                    message.tenantId = reader.uint32();
                    break;
                case /* string interface_name */ 5:
                    message.interfaceName = reader.string();
                    break;
                case /* string private_key */ 6:
                    message.privateKey = reader.string();
                    break;
                case /* string local_address */ 7:
                    message.localAddress = reader.string();
                    break;
                case /* uint32 listen_port */ 8:
                    message.listenPort = reader.uint32();
                    break;
                case /* uint32 interface_mtu */ 9:
                    message.interfaceMtu = reader.uint32();
                    break;
                case /* repeated wireguard.WireGuardPeerConfig peers */ 10:
                    message.peers.push(WireGuardPeerConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated wireguard.Endpoint advertised_endpoints */ 11:
                    message.advertisedEndpoints.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string dns_servers */ 12:
                    message.dnsServers.push(reader.string());
                    break;
                case /* uint32 network_id */ 13:
                    message.networkId = reader.uint32();
                    break;
                case /* repeated string tags */ 14:
                    message.tags.push(reader.string());
                    break;
                case /* uint32 ws_listen_port */ 15:
                    message.wsListenPort = reader.uint32();
                    break;
                case /* bool use_gvisor_net */ 16:
                    message.useGvisorNet = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WireGuardConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* uint32 user_id = 3; */
        if (message.userId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.userId);
        /* uint32 tenant_id = 4; */
        if (message.tenantId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.tenantId);
        /* string interface_name = 5; */
        if (message.interfaceName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.interfaceName);
        /* string private_key = 6; */
        if (message.privateKey !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.privateKey);
        /* string local_address = 7; */
        if (message.localAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.localAddress);
        /* uint32 listen_port = 8; */
        if (message.listenPort !== 0)
            writer.tag(8, WireType.Varint).uint32(message.listenPort);
        /* uint32 interface_mtu = 9; */
        if (message.interfaceMtu !== 0)
            writer.tag(9, WireType.Varint).uint32(message.interfaceMtu);
        /* repeated wireguard.WireGuardPeerConfig peers = 10; */
        for (let i = 0; i < message.peers.length; i++)
            WireGuardPeerConfig.internalBinaryWrite(message.peers[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated wireguard.Endpoint advertised_endpoints = 11; */
        for (let i = 0; i < message.advertisedEndpoints.length; i++)
            Endpoint.internalBinaryWrite(message.advertisedEndpoints[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated string dns_servers = 12; */
        for (let i = 0; i < message.dnsServers.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.dnsServers[i]);
        /* uint32 network_id = 13; */
        if (message.networkId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.networkId);
        /* repeated string tags = 14; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.tags[i]);
        /* uint32 ws_listen_port = 15; */
        if (message.wsListenPort !== 0)
            writer.tag(15, WireType.Varint).uint32(message.wsListenPort);
        /* bool use_gvisor_net = 16; */
        if (message.useGvisorNet !== false)
            writer.tag(16, WireType.Varint).bool(message.useGvisorNet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WireGuardConfig
 */
export const WireGuardConfig = new WireGuardConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint$Type extends MessageType<Endpoint> {
    constructor() {
        super("wireguard.Endpoint", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "wireguard_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Endpoint>): Endpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.host = "";
        message.port = 0;
        message.clientId = "";
        message.wireguardId = 0;
        message.uri = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<Endpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint): Endpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string host */ 2:
                    message.host = reader.string();
                    break;
                case /* uint32 port */ 3:
                    message.port = reader.uint32();
                    break;
                case /* string client_id */ 4:
                    message.clientId = reader.string();
                    break;
                case /* uint32 wireguard_id */ 5:
                    message.wireguardId = reader.uint32();
                    break;
                case /* string uri */ 6:
                    message.uri = reader.string();
                    break;
                case /* string type */ 7:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string host = 2; */
        if (message.host !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.host);
        /* uint32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).uint32(message.port);
        /* string client_id = 4; */
        if (message.clientId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.clientId);
        /* uint32 wireguard_id = 5; */
        if (message.wireguardId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.wireguardId);
        /* string uri = 6; */
        if (message.uri !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.uri);
        /* string type = 7; */
        if (message.type !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.Endpoint
 */
export const Endpoint = new Endpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WireGuardLink$Type extends MessageType<WireGuardLink> {
    constructor() {
        super("wireguard.WireGuardLink", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "from_wireguard_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "to_wireguard_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "up_bandwidth_mbps", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "down_bandwidth_mbps", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "latency_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "to_endpoint", kind: "message", T: () => Endpoint },
            { no: 9, name: "routes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WireGuardLink>): WireGuardLink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fromWireguardId = 0;
        message.toWireguardId = 0;
        message.upBandwidthMbps = 0;
        message.downBandwidthMbps = 0;
        message.latencyMs = 0;
        message.active = false;
        message.routes = [];
        if (value !== undefined)
            reflectionMergePartial<WireGuardLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WireGuardLink): WireGuardLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 from_wireguard_id */ 2:
                    message.fromWireguardId = reader.uint32();
                    break;
                case /* uint32 to_wireguard_id */ 3:
                    message.toWireguardId = reader.uint32();
                    break;
                case /* uint32 up_bandwidth_mbps */ 4:
                    message.upBandwidthMbps = reader.uint32();
                    break;
                case /* uint32 down_bandwidth_mbps */ 5:
                    message.downBandwidthMbps = reader.uint32();
                    break;
                case /* uint32 latency_ms */ 6:
                    message.latencyMs = reader.uint32();
                    break;
                case /* bool active */ 7:
                    message.active = reader.bool();
                    break;
                case /* wireguard.Endpoint to_endpoint */ 8:
                    message.toEndpoint = Endpoint.internalBinaryRead(reader, reader.uint32(), options, message.toEndpoint);
                    break;
                case /* repeated string routes */ 9:
                    message.routes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WireGuardLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 from_wireguard_id = 2; */
        if (message.fromWireguardId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fromWireguardId);
        /* uint32 to_wireguard_id = 3; */
        if (message.toWireguardId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.toWireguardId);
        /* uint32 up_bandwidth_mbps = 4; */
        if (message.upBandwidthMbps !== 0)
            writer.tag(4, WireType.Varint).uint32(message.upBandwidthMbps);
        /* uint32 down_bandwidth_mbps = 5; */
        if (message.downBandwidthMbps !== 0)
            writer.tag(5, WireType.Varint).uint32(message.downBandwidthMbps);
        /* uint32 latency_ms = 6; */
        if (message.latencyMs !== 0)
            writer.tag(6, WireType.Varint).uint32(message.latencyMs);
        /* bool active = 7; */
        if (message.active !== false)
            writer.tag(7, WireType.Varint).bool(message.active);
        /* wireguard.Endpoint to_endpoint = 8; */
        if (message.toEndpoint)
            Endpoint.internalBinaryWrite(message.toEndpoint, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string routes = 9; */
        for (let i = 0; i < message.routes.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.routes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WireGuardLink
 */
export const WireGuardLink = new WireGuardLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WireGuardLinks$Type extends MessageType<WireGuardLinks> {
    constructor() {
        super("wireguard.WireGuardLinks", [
            { no: 1, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WireGuardLink }
        ]);
    }
    create(value?: PartialMessage<WireGuardLinks>): WireGuardLinks {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.links = [];
        if (value !== undefined)
            reflectionMergePartial<WireGuardLinks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WireGuardLinks): WireGuardLinks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated wireguard.WireGuardLink links */ 1:
                    message.links.push(WireGuardLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WireGuardLinks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated wireguard.WireGuardLink links = 1; */
        for (let i = 0; i < message.links.length; i++)
            WireGuardLink.internalBinaryWrite(message.links[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WireGuardLinks
 */
export const WireGuardLinks = new WireGuardLinks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Network$Type extends MessageType<Network> {
    constructor() {
        super("wireguard.Network", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tenant_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cidr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "acl", kind: "message", T: () => AclConfig }
        ]);
    }
    create(value?: PartialMessage<Network>): Network {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.userId = 0;
        message.tenantId = 0;
        message.name = "";
        message.cidr = "";
        if (value !== undefined)
            reflectionMergePartial<Network>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Network): Network {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 user_id */ 2:
                    message.userId = reader.uint32();
                    break;
                case /* uint32 tenant_id */ 3:
                    message.tenantId = reader.uint32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string cidr */ 5:
                    message.cidr = reader.string();
                    break;
                case /* wireguard.AclConfig acl */ 6:
                    message.acl = AclConfig.internalBinaryRead(reader, reader.uint32(), options, message.acl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Network, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 user_id = 2; */
        if (message.userId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.userId);
        /* uint32 tenant_id = 3; */
        if (message.tenantId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.tenantId);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string cidr = 5; */
        if (message.cidr !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cidr);
        /* wireguard.AclConfig acl = 6; */
        if (message.acl)
            AclConfig.internalBinaryWrite(message.acl, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.Network
 */
export const Network = new Network$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AclConfig$Type extends MessageType<AclConfig> {
    constructor() {
        super("wireguard.AclConfig", [
            { no: 1, name: "acls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AclRuleConfig }
        ]);
    }
    create(value?: PartialMessage<AclConfig>): AclConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.acls = [];
        if (value !== undefined)
            reflectionMergePartial<AclConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AclConfig): AclConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated wireguard.AclRuleConfig acls */ 1:
                    message.acls.push(AclRuleConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AclConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated wireguard.AclRuleConfig acls = 1; */
        for (let i = 0; i < message.acls.length; i++)
            AclRuleConfig.internalBinaryWrite(message.acls[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.AclConfig
 */
export const AclConfig = new AclConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AclRuleConfig$Type extends MessageType<AclRuleConfig> {
    constructor() {
        super("wireguard.AclRuleConfig", [
            { no: 1, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "src", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dst", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AclRuleConfig>): AclRuleConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = "";
        message.src = [];
        message.dst = [];
        if (value !== undefined)
            reflectionMergePartial<AclRuleConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AclRuleConfig): AclRuleConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string action */ 1:
                    message.action = reader.string();
                    break;
                case /* repeated string src */ 2:
                    message.src.push(reader.string());
                    break;
                case /* repeated string dst */ 3:
                    message.dst.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AclRuleConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string action = 1; */
        if (message.action !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.action);
        /* repeated string src = 2; */
        for (let i = 0; i < message.src.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.src[i]);
        /* repeated string dst = 3; */
        for (let i = 0; i < message.dst.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.dst[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.AclRuleConfig
 */
export const AclRuleConfig = new AclRuleConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WGPeerRuntimeInfo$Type extends MessageType<WGPeerRuntimeInfo> {
    constructor() {
        super("wireguard.WGPeerRuntimeInfo", [
            { no: 1, name: "public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "preshared_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allowed_ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tx_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "rx_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "persistent_keepalive_interval", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "last_handshake_time_nsec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "last_handshake_time_sec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 100, name: "extra", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<WGPeerRuntimeInfo>): WGPeerRuntimeInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = "";
        message.presharedKey = "";
        message.allowedIps = [];
        message.txBytes = 0n;
        message.rxBytes = 0n;
        message.persistentKeepaliveInterval = 0;
        message.lastHandshakeTimeNsec = 0n;
        message.lastHandshakeTimeSec = 0n;
        message.clientId = "";
        message.endpoint = "";
        message.extra = {};
        if (value !== undefined)
            reflectionMergePartial<WGPeerRuntimeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WGPeerRuntimeInfo): WGPeerRuntimeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string public_key */ 1:
                    message.publicKey = reader.string();
                    break;
                case /* string preshared_key */ 2:
                    message.presharedKey = reader.string();
                    break;
                case /* repeated string allowed_ips */ 3:
                    message.allowedIps.push(reader.string());
                    break;
                case /* uint64 tx_bytes */ 6:
                    message.txBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 rx_bytes */ 7:
                    message.rxBytes = reader.uint64().toBigInt();
                    break;
                case /* uint32 persistent_keepalive_interval */ 8:
                    message.persistentKeepaliveInterval = reader.uint32();
                    break;
                case /* uint64 last_handshake_time_nsec */ 9:
                    message.lastHandshakeTimeNsec = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_handshake_time_sec */ 10:
                    message.lastHandshakeTimeSec = reader.uint64().toBigInt();
                    break;
                case /* string client_id */ 11:
                    message.clientId = reader.string();
                    break;
                case /* string endpoint */ 12:
                    message.endpoint = reader.string();
                    break;
                case /* map<string, string> extra */ 100:
                    this.binaryReadMap100(message.extra, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap100(map: WGPeerRuntimeInfo["extra"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGPeerRuntimeInfo["extra"] | undefined, val: WGPeerRuntimeInfo["extra"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGPeerRuntimeInfo.extra");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WGPeerRuntimeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string public_key = 1; */
        if (message.publicKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publicKey);
        /* string preshared_key = 2; */
        if (message.presharedKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.presharedKey);
        /* repeated string allowed_ips = 3; */
        for (let i = 0; i < message.allowedIps.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.allowedIps[i]);
        /* uint64 tx_bytes = 6; */
        if (message.txBytes !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.txBytes);
        /* uint64 rx_bytes = 7; */
        if (message.rxBytes !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.rxBytes);
        /* uint32 persistent_keepalive_interval = 8; */
        if (message.persistentKeepaliveInterval !== 0)
            writer.tag(8, WireType.Varint).uint32(message.persistentKeepaliveInterval);
        /* uint64 last_handshake_time_nsec = 9; */
        if (message.lastHandshakeTimeNsec !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.lastHandshakeTimeNsec);
        /* uint64 last_handshake_time_sec = 10; */
        if (message.lastHandshakeTimeSec !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.lastHandshakeTimeSec);
        /* string client_id = 11; */
        if (message.clientId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.clientId);
        /* string endpoint = 12; */
        if (message.endpoint !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.endpoint);
        /* map<string, string> extra = 100; */
        for (let k of globalThis.Object.keys(message.extra))
            writer.tag(100, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.extra[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WGPeerRuntimeInfo
 */
export const WGPeerRuntimeInfo = new WGPeerRuntimeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WGDeviceRuntimeInfo$Type extends MessageType<WGDeviceRuntimeInfo> {
    constructor() {
        super("wireguard.WGDeviceRuntimeInfo", [
            { no: 1, name: "private_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "listen_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "peers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WGPeerRuntimeInfo },
            { no: 4, name: "protocol_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "errno", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ping_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 8, name: "interface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "virt_addr_ping_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 10, name: "peer_virt_addr_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 11, name: "peer_config_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => WireGuardPeerConfig } },
            { no: 12, name: "virtual_ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 100, name: "extra", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<WGDeviceRuntimeInfo>): WGDeviceRuntimeInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.privateKey = "";
        message.listenPort = 0;
        message.peers = [];
        message.protocolVersion = 0;
        message.errno = 0;
        message.clientId = "";
        message.pingMap = {};
        message.interfaceName = "";
        message.virtAddrPingMap = {};
        message.peerVirtAddrMap = {};
        message.peerConfigMap = {};
        message.virtualIp = "";
        message.extra = {};
        if (value !== undefined)
            reflectionMergePartial<WGDeviceRuntimeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WGDeviceRuntimeInfo): WGDeviceRuntimeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string private_key */ 1:
                    message.privateKey = reader.string();
                    break;
                case /* uint32 listen_port */ 2:
                    message.listenPort = reader.uint32();
                    break;
                case /* repeated wireguard.WGPeerRuntimeInfo peers */ 3:
                    message.peers.push(WGPeerRuntimeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 protocol_version */ 4:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* int32 errno */ 5:
                    message.errno = reader.int32();
                    break;
                case /* string client_id */ 6:
                    message.clientId = reader.string();
                    break;
                case /* map<uint32, uint32> ping_map */ 7:
                    this.binaryReadMap7(message.pingMap, reader, options);
                    break;
                case /* string interface_name */ 8:
                    message.interfaceName = reader.string();
                    break;
                case /* map<string, uint32> virt_addr_ping_map */ 9:
                    this.binaryReadMap9(message.virtAddrPingMap, reader, options);
                    break;
                case /* map<string, uint32> peer_virt_addr_map */ 10:
                    this.binaryReadMap10(message.peerVirtAddrMap, reader, options);
                    break;
                case /* map<string, wireguard.WireGuardPeerConfig> peer_config_map */ 11:
                    this.binaryReadMap11(message.peerConfigMap, reader, options);
                    break;
                case /* string virtual_ip */ 12:
                    message.virtualIp = reader.string();
                    break;
                case /* map<string, string> extra */ 100:
                    this.binaryReadMap100(message.extra, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: WGDeviceRuntimeInfo["pingMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGDeviceRuntimeInfo["pingMap"] | undefined, val: WGDeviceRuntimeInfo["pingMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGDeviceRuntimeInfo.ping_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap9(map: WGDeviceRuntimeInfo["virtAddrPingMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGDeviceRuntimeInfo["virtAddrPingMap"] | undefined, val: WGDeviceRuntimeInfo["virtAddrPingMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGDeviceRuntimeInfo.virt_addr_ping_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap10(map: WGDeviceRuntimeInfo["peerVirtAddrMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGDeviceRuntimeInfo["peerVirtAddrMap"] | undefined, val: WGDeviceRuntimeInfo["peerVirtAddrMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGDeviceRuntimeInfo.peer_virt_addr_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap11(map: WGDeviceRuntimeInfo["peerConfigMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGDeviceRuntimeInfo["peerConfigMap"] | undefined, val: WGDeviceRuntimeInfo["peerConfigMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = WireGuardPeerConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGDeviceRuntimeInfo.peer_config_map");
            }
        }
        map[key ?? ""] = val ?? WireGuardPeerConfig.create();
    }
    private binaryReadMap100(map: WGDeviceRuntimeInfo["extra"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WGDeviceRuntimeInfo["extra"] | undefined, val: WGDeviceRuntimeInfo["extra"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field wireguard.WGDeviceRuntimeInfo.extra");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WGDeviceRuntimeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string private_key = 1; */
        if (message.privateKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.privateKey);
        /* uint32 listen_port = 2; */
        if (message.listenPort !== 0)
            writer.tag(2, WireType.Varint).uint32(message.listenPort);
        /* repeated wireguard.WGPeerRuntimeInfo peers = 3; */
        for (let i = 0; i < message.peers.length; i++)
            WGPeerRuntimeInfo.internalBinaryWrite(message.peers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 protocol_version = 4; */
        if (message.protocolVersion !== 0)
            writer.tag(4, WireType.Varint).uint32(message.protocolVersion);
        /* int32 errno = 5; */
        if (message.errno !== 0)
            writer.tag(5, WireType.Varint).int32(message.errno);
        /* string client_id = 6; */
        if (message.clientId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientId);
        /* map<uint32, uint32> ping_map = 7; */
        for (let k of globalThis.Object.keys(message.pingMap))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.pingMap[k as any]).join();
        /* string interface_name = 8; */
        if (message.interfaceName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.interfaceName);
        /* map<string, uint32> virt_addr_ping_map = 9; */
        for (let k of globalThis.Object.keys(message.virtAddrPingMap))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint32(message.virtAddrPingMap[k]).join();
        /* map<string, uint32> peer_virt_addr_map = 10; */
        for (let k of globalThis.Object.keys(message.peerVirtAddrMap))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint32(message.peerVirtAddrMap[k]).join();
        /* map<string, wireguard.WireGuardPeerConfig> peer_config_map = 11; */
        for (let k of globalThis.Object.keys(message.peerConfigMap)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            WireGuardPeerConfig.internalBinaryWrite(message.peerConfigMap[k], writer, options);
            writer.join().join();
        }
        /* string virtual_ip = 12; */
        if (message.virtualIp !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.virtualIp);
        /* map<string, string> extra = 100; */
        for (let k of globalThis.Object.keys(message.extra))
            writer.tag(100, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.extra[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message wireguard.WGDeviceRuntimeInfo
 */
export const WGDeviceRuntimeInfo = new WGDeviceRuntimeInfo$Type();
